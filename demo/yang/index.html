<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ç¾Šäº†ä¸ªç¾Š</title>
  <link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
  <script src="js/vue.min.js"></script>
  <style>
    body,
    html,
    div,
    span,
    ul,
    li,
    input,
    p {
      padding: 0;
      margin: 0;
      list-style: none;
      -webkit-tap-highlight-color: transparent;
    }

    #app {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #c3ff8b;
    }

    .main {
      user-select: none;
      width: 348px;
      height: 644px;
      background: url("./img/bg.gif") repeat;
      background-size: 100%;
    }

    .warp {
      /* 24px */
      position: relative;
      width: 336px;
      height: 504px;
      margin: auto;
    }

    /* èƒŒæ™¯ç½‘æ ¼çº¿ */
    .bg {
      height: inherit;
      display: flex;
      flex-direction: column;
      border-top: 1px solid #333;
      border-left: 1px solid #333;
    }

    .bg>li {
      display: flex;
      flex: 1;
    }

    .bg>li>div {
      flex: 1;
      border-bottom: 1px solid #333;
      border-right: 1px solid #333;
      background-color: #c3ff8b;
    }

    /* æ‚¬æµ®æ–¹å— */
    .pie {
      position: absolute;
      top: 0;
      left: 0;
      width: 48px;
      height: 48px;
      line-height: 40px;
      font-size: 28px;
      background-color: #f5ffcd;
      text-align: center;
      cursor: pointer;
      box-sizing: border-box;
      border: 1px solid #222;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: inset 0 -4px 0px #6ea012, inset 0 -6px 0px #bad176;
      transition-property: transform, opacity;
      transition-duration: 0.4s, 0.25s;
    }

    .pie.hover {
      transition: transform 0.15s;
    }

    .pie.moving {
      transition: none;
      pointer-events: none;
    }

    .pie.cover {
      /* ç¦æ­¢é¼ æ ‡ä»»ä½•è¡Œä¸º */
      pointer-events: none;
    }

    .pie::after {
      content: "";
      display: block;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      background-color: rgba(0, 0, 0, 0);
      transition: all 0.3s;
    }

    .pie.cover::after {
      content: "";
      background-color: rgba(0, 0, 0, 0.4);
    }

    .pie.pending {
      pointer-events: none;
      /* transition: transform .15s; */
      z-index: 1;
    }

    /* é˜Ÿåˆ—åŒº */
    .queue {
      height: 48px;
      width: 336px;
      border: 2px solid #503307;
      padding: 4px;
      border-radius: 8px;
      background-color: #c38032;
    }

    .queue_content {
      border-radius: inherit;
      width: 100%;
      height: 100%;
      background-color: #965a1c;
      box-shadow: inset 0 6px 0 #7f4e16;
    }

    /* é“å…·åŒº */
    .prop {
      margin: 16px auto 0px auto;
      display: flex;
      justify-content: space-evenly;
      align-items: center;
    }

    .prop_item {
      position: relative;
      width: 76px;
      height: 56px;
      border: 2px solid #333;
      display: flex;
      border-radius: 6px;
      background-color: #27a2f6;
      box-shadow: 0px 4px 0 rgba(0, 0, 0, 0.3), inset 0px 4px 0px #6dcdfd;
      cursor: pointer;
      text-align: center;
      font-size: 20px;
    }

    .prop_item_i {
      line-height: 50px;
      color: #fff;
      width: inherit;
      height: 50px;
      border-bottom: inherit;
      border-radius: inherit;
    }

    .prop_item.cover {
      pointer-events: none;
    }

    .prop_item.cover::after {
      content: "";
      display: block;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      position: absolute;
      background-color: rgba(0, 0, 0, 0.6);
      cursor: default;
    }

    .tools_count {
      background-color: #000;
      display: block;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      text-align: center;
      position: absolute;
      top: -8px;
      right: -8px;
      font-weight: bold;
      font-size: 14px;
      line-height: 22px;
      box-shadow: 0px 3px 0px rgba(0, 0, 0, 0.3);
    }

    /* é®ç½© */
    .shadow {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 2;
    }

    .shadow_main {
      width: 300px;
      height: 260px;
      position: absolute;
      left: 50%;
      top: 50%;
      background-color: #f5ffcd;
      transform: translate(-50%, -50%);
      border-radius: 20px;
      font-weight: bold;
      text-align: center;
    }

    .shadow_main .title {
      font-size: 46px;
      line-height: 80px;
      color: #333;
    }

    .shadow_main .levelTitle {
      color: #27a2f6;
      font-size: 22px;
    }

    .shadow_main .block {
      font-weight: bold;
      color: #777;
      margin-bottom: 5px;
    }

    .shadow_main .button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translate(-50%);
      border: 1px solid #000;
      width: 120px;
      height: 40px;
      font-size: 18px;
      line-height: 40px;
      border-radius: 8px;
      cursor: pointer;
      background-color: rgb(255, 240, 101);
      color: #333;
    }

    .shadow_main .button:hover {
      background-color: rgb(189, 178, 78);
    }

    .shadow_main .set {
      cursor: pointer;
      color: #333;
    }

    .shadow_main .set:hover {
      text-decoration: underline;
    }

    /* é€‰æ‹©èœå• */
    .menu {
      position: absolute;
      background-color: #c3ff8b;
      display: block;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
    }

    .menu_i {
      width: 200px;
      height: 200px;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background-color: #f5ffcd;
      border: 4px solid #545549;
      z-index: 2;
      border-radius: 20px;
      text-align: center;
      overflow: hidden;
    }

    .menu_i .title {
      line-height: 44px;
      font-size: 24px;
      color: #616159;
      margin-bottom: 16px;
    }

    .menu_i li {
      border-bottom: 1px solid #666;

      color: #555;
      transition: all 0.2s;
    }

    /* å¯¹ç¬¬ä¸€ä¸ªç‰¹æ®Šå¤„ç† */
    .tab1 li:nth-of-type(1) {
      border-top: 1px solid #666;
    }

    .tab1 li {
      font-weight: bold;
      cursor: pointer;
      line-height: 40px;
      font-size: 18px;
    }

    .tab1 li:hover {
      background-color: rgb(180, 181, 127);
      color: #fff;
    }

    /* tab2 */
    .tab2 li,
    .tab3 li {
      height: 40px;
      line-height: 40px;
      flex: 1;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10px;
    }

    .tab2 input {
      width: 110px;
    }

    .menu_i .buttonWarp div {
      height: 36px;
      line-height: 36px;
      text-align: center;
      font-weight: bold;
      color: #616159;
      cursor: pointer;
      transition: all 0.15s;
    }

    .menu_i .buttonWarp div:hover {
      background-color: rgb(180, 181, 127);
      color: #fff;
    }

    .tab2 .buttonWarp div {
      width: 100px;
      float: left;
    }

    .tab2 .buttonWarp div:nth-of-type(1) {
      border-right: 1px solid #666;
      width: 98px;
    }

    .tab3 input {
      width: 80px;
    }

    /* æ’¤é”€æç¤º */
    .revokeTips {
      position: absolute;
      top: 50%;
      left: 50%;
      color: #fff;
      transform: translate(-50%, -50%);
      background-color: #555;
      width: 120px;
      text-align: center;
      line-height: 34px;
      height: 34px;
      border-radius: 6px;
      border: 2px solid #222;
    }
  </style>
</head>

<body>
  <div class="" id="app">
    <div class="main">
      <!-- ä¸»ä½“ -->
      <div class="warp">
        <!-- èƒŒæ™¯ -->
        <!-- <ul class="bg">
                    <li v-for="item in bg">
                        <div v-for="i in item"></div>
                    </li>
                </ul> -->
        <!-- æ‚¬æµ®æ–¹å—åŒºåŸŸ -->
        <!-- <ul class="scene" @click="clickPie($event)"> -->
        <ul class="scene" ref="scene" @touchstart="touchStart($event)" @touchmove="touchMove($event)"
          @touchend="touchEnd($event)" @click="clickPie">
          <li v-for="(item,index) in cardList">
            <div v-for="i in item"
              :class="['pie',{cover:i.isCover},{hover:i.isHover},{pending:i.isPending},{moving:i.moving}]"
              :style="computedStyle(i)" :x="i.x" :y="i.y" :z="index" :key="i.cardId" :cardid="i.cardId">
              {{i.icon}}
            </div>
          </li>
        </ul>
      </div>
      <!-- åˆ—é˜ŸåŒº  queue-->
      <div class="queue">
        <div class="queue_content"></div>
      </div>
      <!-- é“å…·åŒº prop -->
      <div class="prop">
        <div class="prop_item" :class="{'cover':tools.remove == 0 }" @click="remove">
          <div class="prop_item_i">
            <span class="icon">ç§»å‡º</span>
            <span class="tools_count" v-show="tools.remove">{{tools.remove}}</span>
          </div>
        </div>
        <div class="prop_item" :class="{'cover':tools.revoke==0 }" @click="revoke">
          <div class="prop_item_i">
            <span class="icon">æ’¤é”€</span>
            <span class="tools_count" v-show="tools.revoke">{{tools.revoke}}</span>
          </div>
        </div>
        <div class="prop_item" :class="{'cover':tools.shuffle==0 }" @click="shuffle">
          <div class="prop_item_i">
            <span class="icon">æ´—ç‰Œ</span>
            <span class="tools_count" v-show="tools.shuffle">{{tools.shuffle}}</span>
          </div>
        </div>
      </div>
      <!-- é®ç½© -->
      <div class="shadow" v-show="gameStatus">
        <!-- èœå•dialog -->
        <div class="shadow_main">
          <!-- æ ‡é¢˜ -->
          <p class="title" v-if="gameStatus == 'success'">å…³å¡é€šè¿‡</p>
          <p class="title" v-else-if="gameStatus == 'fail'">æ¸¸æˆå¤±è´¥</p>
          <p class="title" v-else-if="gameStatus == 'next'">é€šå…³æˆåŠŸ</p>
          <!-- å…³å¡ç­‰çº§ -->
          <p class="levelTitle" v-if="gameStatus == 'next'">
            å…³å¡ï¼š{{curLevel}}
          </p>
          <!-- æ–¹å—æ•°é‡ -->
          <p class="block" v-if="gameStatus == 'fail'">
            å‰©ä½™æ–¹å—ï¼š{{curPieTotal}}
          </p>
          <p class="block" v-else>æ¶ˆé™¤æ–¹å—ï¼š{{pieTotal}}</p>
          <!-- é€‰é¡¹ -->
          <span class="set" v-if="gameStatus != 'next'"
            @click="menu.showMenu='true';gameStatus='';cardList=[]">âš™é€‰é¡¹</span>
          <!-- æŒ‰é’® -->
          <div class="button" v-if="gameStatus == 'success'" @click="play(menu.mode)">
            é‡æ–°æ¸¸ç©
          </div>
          <div class="button" v-else-if="gameStatus == 'fail'" @click="play(menu.mode)">
            å†æ¬¡å°è¯•
          </div>
          <div class="button" v-else-if="gameStatus == 'next'" @click="play(menu.mode)">
            ä¸‹ä¸€å…³å¡
          </div>
        </div>
      </div>
      <!-- é€‰é¡¹ -->
      <div class="menu" v-show="menu.showMenu">
        <div class="menu_i">
          <div class="tab1" v-if="menu.tab == 0">
            <p class="title">é€‰é¡¹è®¾ç½®</p>
            <ul>
              <li @click="play(1)">æ¨¡æ‹Ÿ</li>
              <li @click="play(2)">å…³å¡</li>
              <li @click="menu.tab=1">è‡ªå®šä¹‰</li>
            </ul>
          </div>
          <!-- è‡ªå®šä¹‰é¢æ¿ -->
          <div class="tab2" v-else-if="menu.tab == 1">
            <ul>
              <li>
                <span> å±‚æ•°:{{menu.custom.numZ}}</span>
                <input type="range" v-model="menu.custom.numZ" name="" id="" min="1" max="14" />
              </li>
              <li>
                <span> å›¾æ¡ˆ:{{menu.custom.iconCount}} </span>

                <input type="range" v-model="menu.custom.iconCount" name="" id="" min="1" max="18" />
              </li>
              <li>
                <span> å¯†åº¦:{{menu.custom.density}} </span>
                <input type="range" v-model="menu.custom.density" name="" id="" step="0.01" min="0.1" max="1" />
              </li>
              <li>
                <span> åŒºé—´:</span>
                <input @click="menu.tab = 2" type="button" value="é€‰æ‹©åŒºé—´èŒƒå›´" />
              </li>
            </ul>
            <div class="buttonWarp">
              <div class="buttonL" @click="menu.tab=0;menu.mode=0">è¿”å›</div>
              <div class="buttonR" @click="play(3)">ç¡®è®¤</div>
            </div>
          </div>
          <div class="tab3" v-else-if="menu.tab == 2">
            <ul>
              <li>
                <span> æ¨ªå‘èµ·ç‚¹:{{menu.custom.range.x[0]}}</span>
                <input v-model="menu.custom.range.x[0]" type="range" name="" id="" min="0" max="8" />
              </li>
              <li>
                <span> æ¨ªå‘ç»ˆç‚¹:{{menu.custom.range.x[1]}} </span>
                <input v-model="menu.custom.range.x[1]" type="range" name="" id="" min="6" max="14" />
              </li>
              <li>
                <span> çºµå‘èµ·ç‚¹:{{menu.custom.range.y[0]}} </span>
                <input v-model="menu.custom.range.y[0]" type="range" name="" id="" step="1" min="0" max="12" />
              </li>
              <li>
                <span> çºµå‘ç»ˆç‚¹:{{menu.custom.range.y[1]}} </span>
                <input v-model="menu.custom.range.y[1]" type="range" name="" id="" step="1" min="6" max="18" />
              </li>
            </ul>
            <div class="buttonWarp">
              <div @click="menu.tab=1">ç¡®è®¤</div>
            </div>
          </div>
        </div>
      </div>
      <!-- æ’¤é”€æç¤º -->
      <div class="revokeTips" v-show="showRevokeTips">æ’¤é”€å†…å®¹ä¸ºç©º</div>
    </div>
  </div>
  <script>
    //å†…å®¹æ ·å¼
    const contentType = {
      1: "ğŸ¥•",
      2: "âœ‚ï¸",
      3: "ğŸ¥¦",
      4: "ğŸ¥›",
      5: "ğŸŒŠ",
      6: "ğŸ§¤",
      7: "ğŸ§µ",
      8: "ğŸŒ±",
      9: "ğŸ”¨",
      10: "ğŸŒ½",
      11: "ğŸŒ¾",
      12: "ğŸ‘",
      13: "ğŸ”¥",
      14: "â˜˜ï¸",
      15: "â­ï¸",
      16: "ğŸ¥",
      17: "ğŸ‰",
      18: "ğŸš€",
    };

    const app = new Vue({
      el: "#app",
      data: {
        bg: [],
        curLevel: 1,
        // æ‰€æœ‰å¡ç‰Œæ•°ç»„
        cardList: [],
        // åˆ—é˜ŸåŒº
        pendingList: [],
        // å¡ç‰‡æ€»æ•°
        pieTotal: 0,
        curPieTotal: 0,
        // é“å…·æ¬¡æ•°
        tools: {
          remove: 1,
          revoke: 2,
          shuffle: 3,
        },
        // é˜´å½±æ–¹å—
        coverList: [],
        // ç”¨äºæ’¤é”€çš„æ•°ç»„
        revokeList: [],
        showRevokeTips: false,
        //  fail success next
        gameStatus: "",
        // é€‰é¡¹å…³è”æ•°æ®
        menu: {
          showMenu: true,
          mode: 0,
          tab: 0,
          custom: {
            numZ: 4,
            iconCount: 4,
            density: 0.2,
            range: {
              x: [2, 12],
              y: [4, 14],
            },
          },
        },
        // ç¦æ­¢ç‚¹å‡»
        ing: false,
        // ç”¨äºç§»åŠ¨ç«¯ç‚¹å‡»
        touch: {
          id: null,
          pie: null,
          start: null,
          move: null,
        },
        isPC: true
      },
      mounted() {
        //åˆå§‹åŒ–èƒŒæ™¯
        this.bg = this.initBg();
        // this.createPie();
        this.isPC = this.isMobileDevice()
      },
      methods: {
        isMobileDevice() {
          // åŒ¹é…å¸¸è§çš„ç§»åŠ¨è®¾å¤‡çš„ç”¨æˆ·ä»£ç†
          const mobileUserAgentRegex =
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
          // è·å–ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²
          const userAgent =
            navigator.userAgent || navigator.vendor || window.opera;
          // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²
          const str = mobileUserAgentRegex.test(userAgent);
          // ä½¿ç”¨ç¤ºä¾‹
          if (!str) {
            return true
          }
          return false
        },
        computedStyle(i) {
          let scale = 1;
          if (i.isOut) scale = 0;
          if (i.isHover) scale = 1.3;
          return {
            transform: `translate(${i.offsetX},${i.offsetY}) scale(${scale}) translateZ(0)`,
            zIndex: i.isHover ? 1 : "",
            opacity: i.isOpacity ? 0 : "",
          };
        },
        touchStart(e) {
          if (this.isPC) return;
          if (this.ing || e.target.nodeName !== "DIV") {
            return;
          }
          this.ing = true;
          // ä½¿ç”¨äº†äº‹ä»¶ä»£ç†ï¼Œæ‰€ä»¥éœ€è¦è¯»å–å±æ€§ä»¥ç¡®å®šå…ƒç´ 
          const x = e.target.getAttribute("x");
          const y = e.target.getAttribute("y");
          const z = e.target.getAttribute("z");
          const id = e.target.getAttribute("cardid");
          const temp = this.coverList;
          const pie = temp[temp.length - 1 - z][y][x];

          pie.isHover = true;
          this.touch.pie = pie;
          this.touch.id = id;
          this.touch.start = [
            e.target.getBoundingClientRect().left,
            e.target.getBoundingClientRect().top,
          ];
        },
        touchMove(e) {
          if (this.isPC) return;

          e.preventDefault();
          this.touch.move = [e.touches[0].clientX, e.touches[0].clientY];
        },
        touchEnd(e) {
          if (this.isPC) return;
          console.log("touchEnd");
          // ç¦æ­¢å¤šæŒ‡æ“ä½œ
          if (this.touch.id !== e.target.getAttribute("cardid")) {
            return;
          }
          this.ing = false;
          // æ²¡æœ‰ç§»åŠ¨ ç›´æ¥æ·»åŠ 
          if (this.touch.move == null) {
            this.addPending(this.touch.pie);
            this.checkCover(this.touch.pie);
          } else {
            // ç§»åŠ¨åˆ¤æ–­æ˜¯å¦å‡ºç•Œ
            const x = this.touch.start[0];
            const y = this.touch.start[1];
            const moveX = this.touch.move[0];
            const moveY = this.touch.move[1];
            // å…ƒç´  48px å¤§å°
            const boolX = moveX > x && moveX < x + 48;
            const boolY = moveY > y && moveY < y + 48;

            if (boolX && boolY) {
              // console.log("èŒƒå›´é‡Œ");
              this.addPending(this.touch.pie);
              this.checkCover(this.touch.pie);
            }
          }
          this.touch.pie.isHover = false;
          this.touch = {
            pie: null,
            start: null,
            move: null,
          };
        },
        initBg() {
          const arr = [];
          const x = 21;
          const y = 14;
          for (let i = 0; i < x; i++) {
            arr.push([]);
            for (let j = 0; j < y; j++) {
              arr[i].push(0);
            }
          }
          return arr;
        },
        // åˆå§‹åŒ–æ•°æ®
        init(mode) {
          this.pieTotal = 0;
          this.curPieTotal = 0;
          this.pendingList = [];
          this.coverList = [];
          this.cardList = [];
          this.gameStatus = "";
          this.ing = false;
        },
        // èœå•é€‰æ‹©
        play(mode) {
          // console.log("play");
          this.menu.mode = mode;
          if (this.gameStatus == "next") {
            this.curLevel++;
          } else {
            this.curLevel = 1;
            this.tools = {
              remove: 1,
              revoke: 2,
              shuffle: 3,
            };
            this.revokeList = [];
          }
          // ç”Ÿæˆæ–¹å—
          this.createPie(mode);
          this.menu.showMenu = false;
        },
        // éšæœºç”Ÿæˆæ–¹å— mode: 0 1 2 3
        createPie(mode = 0) {
          // åˆå§‹åŒ–
          this.init(mode);
          // å—åŸºæœ¬ä¿¡æ¯
          function Pie(x, y, offsetX, offsetY) {
            this.x = x;
            this.y = y;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.realOffsetX = offsetX;
            this.realOffsetY = offsetY;
            // å…ƒç´ ä¸­å¿ƒç‚¹
            this.cx = x * 24 + 24;
            this.cy = y * 24 + 24;
            // å…ƒç´ æ ·å¼
            this.isOut = false;
            this.isPending = false;
            this.isRemove = false;
            this.isCover = false;
            this.isHover = false;
            this.isOpacity = false;
            this.icon = "";
            this.cardId = Math.floor(Math.random() * 1000000);
            // å¼§åº¦
            this.angle = 0;
            this.moveing = false;
          }
          // æ¸²æŸ“æ•°ç»„
          const arr = [];
          // å±‚æ•°
          let numZ = 2;
          // å›¾æ¡ˆæ•°é‡
          let iconCount = 2;
          // æ•°æ®å¸ƒå±€æ•°ç»„
          const tempArrX = 14;
          const tempArrY = 20;
          // è§„åˆ™
          let rule = [
            {
              curZ: 14,
              range: {
                x: [0, 14],
                y: [0, 18],
              },
              density: 0.3,
            },
          ];
          // åˆ¤æ–­åˆ›å»ºæ¨¡å¼
          switch (mode) {
            case 1:
              // æ¨¡æ‹Ÿæ¨¡å¼
              numZ = 12;
              iconCount = 18;
              rule = [
                {
                  curZ: 1,
                  // range: [0, 14],
                  range: {
                    x: [1, 13],
                    y: [1, 13],
                  },
                  density: 0.25,
                  must: [
                    [1, 1],
                    [11, 1],
                    [11, 11],
                    [1, 11],

                    [3, 3],
                    [9, 3],
                    [3, 9],
                    [9, 9],
                    [5, 7],
                    [7, 5],

                    [1, 16],
                    [5, 16],
                    [7, 16],
                    [11, 16],
                  ],
                },
                {
                  curZ: 2,
                  range: {
                    x: [2, 12],
                    y: [2, 12],
                  },
                  density: 1,
                  must: [
                    [0, 0],
                    [2, 0],
                    [2, 2],
                    [0, 2],
                    [12, 0],
                    [10, 0],
                    [10, 2],
                    [12, 2],
                    [12, 12],
                    [12, 10],
                    [10, 12],
                    [10, 10],
                    [0, 10],
                    [0, 12],
                    [2, 10],
                    [2, 12],

                    [0, 16],
                    [2, 16],
                    [4, 16],
                    [6, 16],
                    [8, 16],
                    [10, 16],
                    [12, 16],
                  ],
                },
                {
                  curZ: 3,
                  range: {
                    x: [5, 8],
                    y: [5, 8],
                  },
                  density: 0,
                  must: [
                    [1, 1],
                    [11, 1],
                    [11, 11],
                    [1, 11],

                    [3, 3],
                    [3, 6],
                    [3, 9],
                    [6, 3],
                    [9, 3],

                    [9, 6],
                    [9, 9],
                    [6, 9],

                    [6, 6],
                  ],
                },
                {
                  curZ: 5,
                  range: {
                    x: [2, 12],
                    y: [2, 12],
                  },
                  density: 0.4,
                  must: [
                    [5, 5],
                    [7, 5],
                    [5, 7],
                    [7, 7],

                    [2, 2],
                    [2, 10],
                    [10, 2],
                    [10, 10],
                  ],
                },
                {
                  curZ: 8,
                  range: {
                    x: [3, 11],
                    y: [3, 11],
                  },
                  density: 0.4,
                  must: [[6, 6]],
                },
                {
                  curZ: 12,
                  range: {
                    x: [4, 10],
                    y: [4, 10],
                  },
                  density: 0.55,
                  empty: [[6, 6]],
                },
              ];
              break;
            case 2:
              // å…³å¡æ¨¡å¼
              numZ = Math.min(this.curLevel + 1, 12);
              iconCount = Math.min(this.curLevel + 1, 18);
              rule = [
                {
                  curZ: 12,
                  range: {
                    x: [0, 14],
                    y: [0, 18],
                  },
                  density: 0.25,
                },
              ];
              break;
            case 3:
              // è‡ªå®šä¹‰æ¨¡å¼
              numZ = this.menu.custom.numZ;
              iconCount = this.menu.custom.iconCount;
              rule = [
                {
                  curZ: 14,
                  range: {
                    // è½¬æ¢ä¸ºnumberç±»å‹
                    x: [
                      this.menu.custom.range.x[0] - 0,
                      this.menu.custom.range.x[1] - 0,
                    ],
                    y: [
                      this.menu.custom.range.y[0] - 0,
                      this.menu.custom.range.y[1] - 0,
                    ],
                  },
                  density: this.menu.custom.density,
                },
              ];
              break;
          }
          // iconæ¸²æŸ“æ•°é‡
          let tempRule;
          // ç”¨äºåŒ¹é…rule
          let countZ = 0;
          // å¡«å……æ•°ç»„ å±‚æ•° Z
          for (let z = 0; z < numZ; z++) {
            // å„å±‚è§„åˆ™
            tempRule = rule[countZ];
            if (z < rule[countZ].curZ) {
              tempRule = rule[countZ];
            } else {
              countZ++;
              if (z < rule[countZ].curZ) {
                tempRule = rule[countZ];
              }
            }
            // å¡ç‰‡æ€»æ•°ç»„
            arr.push([]);
            // æ•°å€¼å¸ƒå±€
            const tempCoverList = [];
            // æ¯å±‚åˆå§‹æ•°å€¼å¸ƒå±€
            for (let i = 0; i < tempArrY; i++) {
              // åˆ›å»ºæ¯è¡Œçš„ç©ºæ•°ç»„
              tempCoverList[i] = [];
              for (let j = 0; j < tempArrX; j++) {
                tempCoverList[i][j] = 0;
              }
            }
            // å¿…å¡«åŒºåŸŸ
            if (tempRule.must) {
              tempRule.must.forEach((item) => {
                const x = item[1];
                const y = item[0];

                const offsetX = y * 24 + "px";
                const offsetY = x * 24 + "px";

                const pie = new Pie(y, x, offsetX, offsetY);
                arr[z].push(pie);
                // coverList
                tempCoverList[x][y] = pie;
                tempCoverList[x + 1][y] = pie;
                tempCoverList[x][y + 1] = pie;
                tempCoverList[x + 1][y + 1] = pie;

                this.pieTotal++;
              });
            }
            // è¡Œ
            for (
              let i = tempRule.range.y[0];
              i < tempRule.range.y[1] - 1;
              i++
            ) {
              // åˆ—
              for (
                let j = tempRule.range.x[0];
                j < tempRule.range.x[1] - 1;
                j++
              ) {
                // å·²å­˜åœ¨è·³è¿‡
                if (
                  tempCoverList[i][j] ||
                  tempCoverList[i][j + 1] ||
                  tempCoverList[i + 1][j + 1] ||
                  tempCoverList[i + 1][j]
                ) {
                  continue;
                }
                // ç•™ç©ºåŒºåŸŸ
                if (tempRule.empty) {
                  const bool = tempRule.empty.some((item) => {
                    return (
                      (i == item[1] ||
                        i == item[1] + 1 ||
                        i == item[1] - 1) &&
                      (j == item[0] || j == item[0] + 1 || j == item[0] - 1)
                    );
                  });
                  if (bool) {
                    continue;
                  }
                }
                // å¡«å……ä¿¡æ¯
                if (Math.random() < tempRule.density) {
                  const x = j;
                  const y = i;
                  const offsetX = j * 24 + "px";
                  const offsetY = i * 24 + "px";
                  const pie = new Pie(x, y, offsetX, offsetY);

                  // ä¿å­˜æ•°ç»„
                  arr[z].push(pie);
                  // å››ä¸ªæ–¹å—å¡«å……
                  tempCoverList[i][j] = pie;
                  tempCoverList[i + 1][j] = pie;
                  tempCoverList[i][j + 1] = pie;
                  tempCoverList[i + 1][j + 1] = pie;

                  this.pieTotal++;
                }
              }
            }
            this.coverList.push(tempCoverList);
          }
          // é’ˆå¯¹ç‰¹æ®Šæ–¹å—å¤„ç†
          if (mode == 1) {
            for (let i = 0; i < 11; i++) {
              let x = 0;
              let y = 14;
              let offsetX;
              let offsetY = "336px";
              const tempCoverList = this.coverList[11 - i];

              offsetX = i * 6 + "px";
              let pie = new Pie(x, y, offsetX, offsetY);

              arr[arr.length - 1 - i].push(pie);

              tempCoverList[y][x] = pie;
              tempCoverList[y + 1][x] = pie;
              tempCoverList[y][x + 1] = pie;
              tempCoverList[y + 1][x + 1] = pie;
              // å³ä¾§
              x = 12;
              offsetX = 288 - i * 6 + "px";

              pie = new Pie(x, y, offsetX, offsetY);
              arr[arr.length - 1 - i].push(pie);
              tempCoverList[y][x] = pie;
              tempCoverList[y + 1][x] = pie;
              tempCoverList[y][x + 1] = pie;
              tempCoverList[y + 1][x + 1] = pie;

              this.pieTotal += 2;
            }
          }
          // æ•°ç»„å€’åºï¼Œç¬¦åˆæ¸²æŸ“è§„åˆ™
          arr.reverse();
          // æ•°é‡ä¸è¶³
          if (this.pieTotal < 3) {
            this.createPie(mode);
            return;
          }
          // å–3çš„å€æ•°ï¼Œä»åº•éƒ¨å¼¹å‡º
          if (this.pieTotal % 3) {
            // if (false) {
            const r = this.pieTotal % 3;
            const cover = this.coverList;
            for (let i = 0; i < r; i++) {
              const a = arr[0].shift();
              this.pieTotal--;

              cover[cover.length - 1][a.y][a.x] = 0;
              cover[cover.length - 1][a.y + 1][a.x] = 0;
              cover[cover.length - 1][a.y][a.x + 1] = 0;
              cover[cover.length - 1][a.y + 1][a.x + 1] = 0;
            }
          }
          // å¡«å……å›¾æ¡ˆ  å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®
          const iconArrIndex = [];
          arr.forEach((element, index) => {
            element.forEach((item, index_i) => {
              iconArrIndex.push([index, index_i]);
            });
          });
          // æ‰“ä¹±æ•°ç»„ä½ç½®ï¼Œéšæœºä½ç½®æ·»åŠ icon
          this.shuffleArray(iconArrIndex);
          // icon å¾ªç¯èµ‹å€¼
          let a = 0;
          one: while (true) {
            // icon å¾ªç¯æ¸²æŸ“
            for (let i = 1; i <= iconCount; i++) {
              // è¿ç»­èµ‹å€¼ä¸‰ä¸ª
              for (let j = 0; j < 3; j++) {
                const temp = iconArrIndex[a];
                arr[temp[0]][temp[1]].icon = contentType[i];
                // end
                if (a == iconArrIndex.length - 1) {
                  break one;
                }
                a++;
              }
            }
          }
          // åŠ¨ç”»
          arr.forEach((element) => {
            element.forEach((item) => {
              item.offsetX = "144px";
              item.offsetY = "216px";
            });
          });
          this.ing = true;
          setTimeout(() => {
            arr.forEach((element) => {
              element.forEach((item) => {
                item.offsetX = item.realOffsetX;
                item.offsetY = item.realOffsetY;
              });
            });
            setTimeout(() => {
              this.ing = false;
            }, 400);
          }, 400);
          // èµ‹å€¼
          this.curPieTotal = this.pieTotal;
          this.cardList = arr;
          this.checkCover();
        },
        // ç‚¹å‡»äº¤äº’
        clickPie(e) {
          if (!this.isPC) return;
          console.log("click");
          if (this.ing || e.target.nodeName !== "DIV") {
            return;
          }
          const x = e.target.getAttribute("x");
          const y = e.target.getAttribute("y");
          const z = e.target.getAttribute("z");
          const temp = this.coverList;
          const pie = temp[temp.length - 1 - z][y][x];

          this.addPending(pie);
          this.checkCover(pie);
        },
        // æ·»åŠ è‡³é˜Ÿåˆ—åŒº
        addPending(e) {
          // console.log("æ·»åŠ åˆ—é˜Ÿ");
          // æ£€æŸ¥æ¡ä»¶
          e.offsetY = "510px";
          // æ‰¾åˆ°æœ€åä¸€ä¸ªç›¸åŒå…ƒç´ 
          let index = -1;
          for (let i = 0; i < this.pendingList.length - 1; i++) {
            if (e.icon == this.pendingList[i].icon) {
              index = i;
            }
          }
          if (index !== -1) {
            // æ”¹å˜pendingListå…ƒç´ ä½ç½®
            const list1 = this.pendingList.slice(0, index + 1);
            const list2 = this.pendingList.slice(
              index + 1,
              this.pendingList.length
            );
            // æ‹¼æ¥æ–°æ•°ç»„
            this.pendingList = [...list1, e, ...list2];
          } else {
            this.pendingList.push(e);
          }
          // æ‰§è¡ŒåŠ¨ç”»
          this.pendingAnimation();
          e.isPending = true;
          // æ’¤é”€æ•°ç»„æ·»åŠ 
          this.revokeList.push(e);
          // æ£€æŸ¥æ¶ˆé™¤
          this.check(e);
        },
        // pendingListæ’åºåŠ¨ç”»
        pendingAnimation() {
          this.pendingList.forEach((item, index) => {
            item.offsetX = index * 48 + "px";
          });
        },
        // æ£€æŸ¥é®ç½©
        checkCover(pie) {
          // console.log("æ£€æŸ¥é®ç½©");
          // ç‚¹å‡»
          if (pie) {
            const startX = pie.x <= 0 ? 0 : pie.x - 1;
            const endX = pie.x >= 14 ? 14 : pie.x + 1;
            const startY = pie.y <= 0 ? 0 : pie.y - 1;
            const endY = pie.y >= 18 ? 18 : pie.y + 1;

            const coverArray = this.coverList;
            // å¾ªç¯ç‚¹å‡»æ–¹å—å‘¨å›´ä¹å®«æ ¼
            for (let z = coverArray.length - 1; z >= 0; z--) {
              for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                  // ç¡®ä¿æœ‰æ•ˆæ•°æ®
                  const item = coverArray[z][y][x];
                  if (item) {
                    if (item.isPending || item.isOut) {
                      continue;
                    } else {
                      // å…ˆè®©æ‰€æœ‰å…ƒç´ æ˜¾ç¤ºå†åˆ¤æ–­éšè—
                      item.isCover = false;
                      // console.log(item.icon, [item.x, item.y, z] + '-----------');
                      // æ£€æŸ¥ä¸Šå±‚
                      for (let countZ = z - 1; countZ >= 0; countZ--) {
                        // ä¸€ä¸ªæ–¹å—å››ä¸ªæ ¼å­
                        let a, b, c, d;
                        a = coverArray[countZ][item.y][item.x];
                        b = coverArray[countZ][item.y + 1][item.x];
                        c = coverArray[countZ][item.y][item.x + 1];
                        d = coverArray[countZ][item.y + 1][item.x + 1];
                        // ä»¥ä¸‹æƒ…å†µéƒ½ä¸ç®—é®æŒ¡
                        if (!a || a.isPending || a.isOut || a.isRemove) a = 0;
                        if (!b || b.isPending || b.isOut || b.isRemove) b = 0;
                        if (!c || c.isPending || c.isOut || c.isRemove) c = 0;
                        if (!d || d.isPending || d.isOut || d.isRemove) d = 0;

                        if (a || b || c || d) {
                          item.isCover = true;
                          // console.log("æœ‰è¦†ç›–");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // åˆå§‹åŒ–
          else {
            const coverArray = this.coverList;
            // å±‚
            for (let z = coverArray.length - 1; z >= 0; z--) {
              // è¡Œ
              for (let x = 0; x < coverArray[z].length; x++) {
                // åˆ—
                for (let y = 0; y < coverArray[z][x].length; y++) {
                  // æœ‰æ•ˆæ•°æ®
                  if (coverArray[z][x][y]) {
                    // ä¸ä¸Šå±‚æ¯”è¾ƒ
                    for (let arrZ = z - 1; arrZ >= 0; arrZ--) {
                      if (coverArray[arrZ][x][y]) {
                        coverArray[z][x][y].isCover = true;
                      }
                    }
                  }
                }
              }
            }
          }
        },
        // æ£€æŸ¥æ¶ˆé™¤æˆ–æ¸¸æˆèƒœåˆ©
        check(e) {
          // console.log("æ£€æŸ¥");
          const tempList = this.pendingList;
          let frist = -1;
          let last = 0;
          // ä¿å­˜ç›¸åŒå—ï¼Œå¯¹cardlistçš„å¼•ç”¨
          const arr = [];
          // è®°å½•ç›¸åŒå—ä½ç½®
          tempList.forEach((element, i) => {
            if (e.icon == tempList[i].icon) {
              if (frist == -1) {
                frist = i;
              }
              last = i;
              arr.push(tempList[i]);
            }
          });
          // æ»¡ä¸‰ä¸ªæ¶ˆé™¤
          if (last - frist == 2) {
            // ç¦æ­¢ç‚¹å‡»
            this.ing = true;
            // æ’¤é”€æ•°ç»„æ¸…ç©º
            this.revokeList = [];
            // ç­‰å¾…åŠ¨ç”»
            setTimeout(() => {
              arr.forEach((item) => {
                item.isOut = true;
              });
              // é‡æ–°æ’åº
              setTimeout(() => {
                this.pendingAnimation();
                this.ing = false;
              }, 200);
            }, 400);

            tempList.splice(frist, 3);
            this.curPieTotal -= 3;
          }
          // èµ¢
          if (this.curPieTotal == 0) {
            // åˆ¤æ–­æ˜¯å¦ä½å…³å¡æ¨¡å¼
            // console.log("æ¸¸æˆèƒœåˆ©");
            setTimeout(() => {
              if (this.menu.mode == 2) {
                this.gameStatus = "next";
              } else {
                this.gameStatus = "success";
              }
              this.ing = true;
              // æ¸…ç©ºåˆ—è¡¨é¿å…æ¸²æŸ“åŠ¨ç”»
              this.cardList = [];
            }, 500);
          }
          // è¾“
          if (this.pendingList.length === 7) {
            this.ing = true;
            setTimeout(() => {
              this.gameStatus = "fail";
            }, 500);
            // console.log("æ¸¸æˆå¤±è´¥");
          }
        },
        // remove ç§»å‡º
        remove() {
          // ä»å‰é¢æ’¤é”€
          // console.log("ç§»å‡º");
          if (!this.tools.remove) {
            // console.log("æ¬¡æ•°ä¸è¶³");
            return;
          }
          if (!this.pendingList.length) {
            // console.log("åˆ—é˜Ÿä¸ºç©º");
            return;
          }
          // æ¬¡æ•°å‡ä¸€
          this.tools.remove--;
          // æ’¤é”€æ•°ç»„æ¸…ç©º
          this.revokeList = [];
          // å›ºå®šyè½´ä½ç½®
          const offsetY = "456px";
          // åˆ¤å®šåŒºæ•°ç»„
          const tempList = this.pendingList;
          // è¦åˆ é™¤å…ƒç´ çš„ä¸ªæ•°
          let count = tempList.length > 3 ? 3 : tempList.length;
          for (let i = 0; i < count; i++) {
            tempList[i].isRemove = true;
            tempList[i].isPending = false;
            tempList[i].offsetY = offsetY;
            tempList[i].offsetX = 96 + i * 48 + "px";
            tempList[i].realOffsetX = tempList[i].offsetX;
            tempList[i].realOffsetY = tempList[i].offsetY;
          }
          this.pendingList.splice(0, count);
          this.pendingAnimation();
        },
        // Revoke æ’¤é”€
        revoke() {
          // ç§»é™¤åä¸èƒ½æ’¤é”€ï¼Œä¸‰æ¶ˆåä¸èƒ½æ’¤é”€
          // console.log("æ’¤é”€");
          // æ’¤é”€æ•°ç»„ä¸ºç©º
          if (!this.revokeList.length || !this.tools.revoke) {
            // console.log("åˆ—é˜Ÿä¸ºç©º");
            if (!this.showRevokeTips) {
              this.showRevokeTips = true;
              setTimeout(() => {
                this.showRevokeTips = false;
              }, 2000);
            }
            return;
          }
          // æ¬¡æ•°å‡ä¸€
          this.tools.revoke--;
          const len = this.revokeList.length;
          const p = this.revokeList[len - 1];
          // ç§»å›åˆ°å¸ƒå±€åŒº
          p.offsetX = p.realOffsetX;
          p.offsetY = p.realOffsetY;
          p.isPending = false;
          // åˆ é™¤æŒ‡å®šå…ƒç´ 
          const index = this.pendingList.findIndex((item) => {
            return item.cardId == p.cardId;
          });
          // é˜Ÿåˆ—åŒºç§»é™¤å…ƒç´ 
          this.pendingList.splice(index, 1);
          //
          this.revokeList.pop();
          //
          this.pendingAnimation();
          this.checkCover(p);
        },
        // æ´—ç‰Œ
        shuffle() {
          if (!this.tools.shuffle || this.ing) {
            return;
          }
          this.ing = true;
          const that = this;
          // æ¬¡æ•°å‡ä¸€
          this.tools.shuffle--;
          // 0åº•å±‚ 1ä¸Šå±‚
          // ä¸­å¿ƒç‚¹
          let cx = 144;
          let cy = 216;
          // åŠå¾„
          let r = 44;
          // ä¸´æ—¶ä¿å­˜å¯æ“ä½œå…ƒç´ 
          const pieList = [];
          that.cardList.forEach((element) => {
            element.forEach((item) => {
              // ç§»å‡ºåŒºå’Œåˆ¤å®šåŒºè·³è¿‡
              if (
                item.isPending == false &&
                item.isRemove == false &&
                item.isOut == false
              ) {
                // å…ƒç´ åŸä½ç½®ç›¸å¯¹äºä¸­å¿ƒç‚¹å¼§åº¦
                item.angle = Math.atan2(item.cy - cy, item.cx - cx);
                pieList.push(item);
              }
            });
          });
          //  åŠ¨ç”»äº‹ä»¶
          let animationId = null;
          const totalDuration = 700; // æ—‹è½¬ä¸€å‘¨çš„æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
          const frameDuration = 16; // å‡è®¾æ¯å¸§è€—æ—¶16æ¯«ç§’ï¼ˆçº¦60FPSï¼‰
          // æ¯ä¸€å¸§çš„å¼§åº¦
          const angleIncrement =
            (2 * Math.PI) / (totalDuration / frameDuration);
          // å½“å‰å¼§åº¦
          let angle = 0;
          // å›´ç»•åœ†å½¢è½¨è¿¹è¿åŠ¨
          function updatePiePosition() {
            // éå†æ¯ä¸ªå…ƒç´ ï¼Œæ›´æ–°å…¶ä½ç½®
            pieList.forEach((item, index) => {
              if (index >= pieList.length - 50) {
                // è®¡ç®—æ¯ä¸ªæ­£æ–¹å½¢çš„xå’Œyåæ ‡ï¼ˆç›¸å¯¹äºå›´ç»•ä¸­å¿ƒåœ†å½¢è½¨è¿¹ï¼‰
                const mpx = cx + r * Math.cos(angle + item.angle);
                const mpy = cy + r * Math.sin(angle + item.angle);
                // å…ƒç´ ç§»åŠ¨
                item.offsetX = mpx + "px";
                item.offsetY = mpy + "px";
                item.moving = true;
              }
            });
            // åŠå¾„å¢åŠ åœ†åœˆå˜å¤§
            r += 0.76;
            // æ›´æ–°è§’åº¦ä»¥ä¾¿ä¸‹ä¸€å¸§ä½¿ç”¨
            angle -= angleIncrement;
            // å¦‚æœè§’åº¦è¶…è¿‡ä¸€åœˆï¼Œåˆ™é‡ç½®ä¸º0
            // if (angle >= 2 * Math.PI) {
            //     angle = 0;
            // }
            //  æ˜¯å¦è¯¥ç»“æŸæ—‹è½¬
            if (r < 108) {
              animationId = requestAnimationFrame(updatePiePosition);
            } else {
              // ç»“æŸæ—‹è½¬
              cancelAnimationFrame(animationId);
              pieList.forEach((item, index) => {
                if (index >= pieList.length - 50) {
                  item.offsetX = item.realOffsetX;
                  item.offsetY = item.realOffsetY;
                  item.moving = false;
                } else {
                  item.isOpacity = false;
                }
              });
              that.ing = false;
            }
          }
          // åŠ¨ç”»å¼€å§‹å‰
          function initAnimation() {
            pieList.forEach((item, index) => {
              if (index >= pieList.length - 50) {
                // è®¡ç®—æ¯ä¸ªæ­£æ–¹å½¢çš„xå’Œyåæ ‡ï¼ˆç›¸å¯¹äºå®¹å™¨ä¸­å¿ƒï¼‰
                const mpx = cx + r * Math.cos(angle + item.angle);
                const mpy = cy + r * Math.sin(angle + item.angle);
                // å…ƒç´ ç§»åŠ¨
                item.offsetX = mpx + "px";
                item.offsetY = mpy + "px";
              } else {
                item.isOpacity = true;
              }
            });
            setTimeout(() => {
              // è°ƒç”¨åŠ¨ç”»
              requestAnimationFrame(updatePiePosition);
              // æ‰“ä¹±æ•°ç»„
              const tempPieList = [...pieList];
              that.shuffleArray(tempPieList);
              // æ›´æ”¹åŸæ•°ç»„icon
              let a = 0;
              that.cardList.forEach((element) => {
                element.forEach((item) => {
                  if (
                    item.isPending == false &&
                    item.isRemove == false &&
                    item.isOut == false
                  ) {
                    item.icon = tempPieList[a].icon;
                    a++;
                  }
                });
              });
            }, 300);
          }
          initAnimation();
        },
        getRandom(n, m) {
          return Math.floor(Math.random() * (m - n + 1) + n);
        },
        shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
          return array;
        },
      },
    });
  </script>
</body>

</html>